---
import { fetchMenu } from "@/services/menus/fetch-menu";
import { fetchMenuByPath } from "@/services/menus/fetch-menu-by-path";
import { fetchRestaurantSettings, fetchRestaurantSettingsByPath } from "@/services/menus/fetch-restaurant-settings";
import { checkAccountAccess } from "@/services/account/check-account-access";
import type { IMenu, AccountAccess } from "@/types/menu";
import Menu from "@/components/Menu.astro";
import MenuLayout from "@/layouts/MenuLayout.astro";
import AccountUnavailable from "@/components/AccountUnavailable.astro";
import { MenuCache } from "@/components/MenuCache";

const { type, identifier } = Astro.params;

const PATH_TYPES = {
  ACCOUNT_ID: "qr",
  ACCOUNT_PATH: "v",
}

// Step 1: Get account ID and check access FIRST (lightweight query)
let accountId: string | undefined;
let accountSettings;
let accountAccess: AccountAccess = { hasAccess: true, level: 'active' };

if (type === PATH_TYPES.ACCOUNT_ID) {
  accountId = identifier as string;
} else if (type === PATH_TYPES.ACCOUNT_PATH) {
  // For vanity URLs, we need to resolve the path to account ID first
  const settingsResponse = await fetchRestaurantSettingsByPath(identifier as string);
  accountSettings = settingsResponse.data;
  accountId = accountSettings?.account_id;
}

// Check account access before fetching heavy menu data
if (accountId) {
  accountAccess = await checkAccountAccess(accountId);
}

// Step 2: Only fetch full menu data if account has access
let data, error;
if (accountAccess.hasAccess && accountId) {
  if (type === PATH_TYPES.ACCOUNT_ID) {
    // Fetch menu and settings in parallel for better performance
    const [menuResponse, settingsResponse] = await Promise.all([
      fetchMenu(accountId),
      fetchRestaurantSettings(accountId)
    ]);
    data = menuResponse.data;
    error = menuResponse.error;
    accountSettings = settingsResponse.data;
  } else if (type === PATH_TYPES.ACCOUNT_PATH) {
    // We already have settings from above, just fetch menu
    const menuResponse = await fetchMenu(accountId);
    data = menuResponse.data;
    error = menuResponse.error;
  }
} else if (!accountId && type !== PATH_TYPES.ACCOUNT_ID && type !== PATH_TYPES.ACCOUNT_PATH) {
  error = new Error(`Unknown route type: ${type}`);
}

const menu = data as IMenu;

// Get theme for unavailable page (default to light if no menu)
const theme = (menu?.appearance?.theme || "light") as "light" | "dark";

// Cache the response at Vercel's edge for better performance
if (!error && menu && accountAccess.hasAccess) {
  Astro.response.headers.set(
    'Cache-Control',
    'public, s-maxage=60, stale-while-revalidate=300'
  );
} else {
  // Don't cache error or unavailable responses
  Astro.response.headers.set('Cache-Control', 'no-store');
}
---

{/* Show unavailable page if account doesn't have access */}
{!accountAccess.hasAccess ? (
  <MenuLayout menu={menu} accountSettings={accountSettings}>
    <AccountUnavailable 
      accountSettings={accountSettings}
      theme={theme}
      level={accountAccess.level}
      message={accountAccess.message}
    />
  </MenuLayout>
) : (
  <MenuLayout menu={menu} accountSettings={accountSettings}>
    {/* Client-side cache for instant navigation between menu pages */}
    {menu && (
      <MenuCache 
        client:load
        type={type as 'qr' | 'v'}
        identifier={identifier as string}
        menu={menu}
        accountSettings={accountSettings}
      />
    )}
    <Menu
      menu={menu}
      account={type === PATH_TYPES.ACCOUNT_ID ? identifier : undefined}
      accountPath={type === PATH_TYPES.ACCOUNT_PATH ? identifier : undefined}
      accountSettings={accountSettings}
      error={error}
    />
  </MenuLayout>
)}
